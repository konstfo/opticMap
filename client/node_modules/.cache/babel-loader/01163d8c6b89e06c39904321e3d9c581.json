{"ast":null,"code":"/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;\n!function (undefined) {\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  } //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n\n\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n\n    var listeners = [],\n        leaf,\n        len,\n        branch,\n        xTree,\n        xxTree,\n        isolatedBranch,\n        endReached,\n        typeLength = type.length,\n        currentType = type[i],\n        nextType = type[i + 1];\n\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n\n        return [tree];\n      }\n    }\n\n    if (currentType === '*' || currentType === '**' || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 1));\n          }\n        }\n\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === '*';\n\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if (branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i + 2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i + 1));\n    }\n\n    xTree = tree['*'];\n\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1);\n    }\n\n    xxTree = tree['**'];\n\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        } // Build arrays of matching next branches and others.\n\n\n        for (branch in xxTree) {\n          if (branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {\n                '**': isolatedBranch\n              }, i + 1);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice(); //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n\n    for (var i = 0, len = type.length; i + 1 < len; i++) {\n      if (type[i] === '**' && type[i + 1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else if (typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        } else if (isArray(tree._listeners)) {\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n\n        return true;\n      }\n\n      name = type.shift();\n    }\n\n    return true;\n  } // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function (n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function (event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function (event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n    this.on(event, listener);\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function () {\n    this._events || init.call(this);\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    } // Loop through the *_all* functions and invoke them.\n\n\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n\n        this._all[i].apply(this, args);\n      }\n    } // If there is no 'error' event listener then throw.\n\n\n    if (type === 'error') {\n      if (!this._all && !this._events.error && !(this.wildcard && this.listenerTree.error)) {\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n\n        return false;\n      }\n    }\n\n    var handler;\n\n    if (this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n\n      if (arguments.length === 1) {\n        handler.call(this);\n      } else if (arguments.length > 1) switch (arguments.length) {\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        // slower\n\n        default:\n          var l = arguments.length;\n          var args = new Array(l - 1);\n\n          for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n          handler.apply(this, args);\n      }\n\n      return true;\n    } else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n\n      return listeners.length > 0 || !!this._all;\n    } else {\n      return !!this._all;\n    }\n  };\n\n  EventEmitter.prototype.on = function (type, listener) {\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n\n    this._events || init.call(this); // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n\n    this.emit('newListener', type, listener);\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else if (typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    } else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener); // Check for listener leak\n\n\n      if (!this._events[type].warned) {\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    } // Add the function to the event listener collection.\n\n\n    this._all.push(fn);\n\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function (type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,\n        leafs = [];\n\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({\n        _listeners: handlers\n      });\n    }\n\n    for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n\n      if (isArray(handlers)) {\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if (this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        } else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if (this.wildcard) {\n            delete leaf._listeners;\n          } else {\n            delete this._events[type];\n          }\n        }\n\n        return this;\n      } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n        if (this.wildcard) {\n          delete leaf._listeners;\n        } else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function (fn) {\n    var i = 0,\n        l = 0,\n        fns;\n\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n\n      for (i = 0, l = fns.length; i < l; i++) {\n        if (fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    } else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n    if (!this._events[type]) this._events[type] = [];\n\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function () {\n    if (this._all) {\n      return this._all;\n    } else {\n      return [];\n    }\n  };\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(function () {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  } else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();","map":{"version":3,"sources":["C:/Users/asus/Documents/javascript_studying/opticMap/optic-map/node_modules/eventemitter2/lib/eventemitter2.js"],"names":["undefined","isArray","Array","_isArray","obj","Object","prototype","toString","call","defaultMaxListeners","init","_events","_conf","configure","conf","delimiter","maxListeners","wildcard","newListener","listenerTree","EventEmitter","searchListenerTree","handlers","type","tree","i","listeners","leaf","len","branch","xTree","xxTree","isolatedBranch","endReached","typeLength","length","currentType","nextType","_listeners","push","hasOwnProperty","concat","growListenerTree","listener","split","slice","name","shift","warned","m","console","error","trace","setMaxListeners","n","event","once","fn","many","ttl","self","Error","off","apply","arguments","_origin","on","emit","_all","l","args","handler","ns","onAny","addListener","leafs","iLeaf","position","splice","offAny","fns","removeListener","removeAllListeners","listenersAny","define","amd","exports","EventEmitter2","window"],"mappings":"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","sourcesContent":["/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n"]},"metadata":{},"sourceType":"script"}